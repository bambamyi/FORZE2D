// DO NOT MODIFY THE HEADERS IF FORZE IS ALREADY COMPILED AS A STATIC LIBRARY
#ifndef __FZPARTICLESYSTEM_H_INCLUDED__
#define __FZPARTICLESYSTEM_H_INCLUDED__
/*
 * FORZE ENGINE: http://forzefield.com
 *
 * Copyright (c) 2011-2012 FORZEFIELD Studios S.L.
 * Copyright (c) 2012 Manuel Martínez-Almeida
 * Copyright (c) 2008-2010 Ricardo Quesada
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 @author Manuel Martínez-Almeida
 */

#include "FZProtocols.h"
#include "FZNode.h"


//using namespace STD;

namespace FORZE {
    
    //! @enum
    enum {
        //! The Particle emitter lives forever
        kFZParticleDurationInfinity = -1,
        
        //! The starting size of the particle is equal to the ending size
        kFZParticleStartSizeEqualToEndSize = -1,
        
        //! The starting radius of the particle is equal to the ending radius
        kFZParticleStartRadiusEqualToEndRadius = -1,
    };
    
    //! @enum
    enum {
        //! Gravity mode (A mode)
        kFZParticleModeGravity,
        
        //! Radius mode (B mode)
        kFZParticleModeRadius,	
    };
    
    
    /** @typedef tCCPositionType
     possible types of particle positions
     */
    typedef enum {
        /** Living particles are attached to the world and are unaffected by emitter repositioning. */
        kFZPositionTypeFree,
        
        /** Living particles are attached to the world but will follow the emitter repositioning.
         Use case: Attach an emitter to an sprite, and you want that the emitter follows the sprite.
         */
        kFZPositionTypeRelative,
        
        /** Living particles are attached to the emitter and are translated along with it. */
        kFZPositionTypeGrouped,
    }tFZPositionType;

    
    /** @struct tCCParticle
     Structure that contains the values of each particle
     */
    typedef struct _sFZParticle {
        fzPoint		pos;
        fzPoint		startPos;
        
        fzColor4F   color;
        fzColor4F   deltaColor;
        
        fzFloat		size;
        fzFloat		deltaSize;
        
        fzFloat		rotation;
        fzFloat		deltaRotation;
        
        fzFloat		timeToLive;
        
        union {
            // Mode A: gravity, direction, radial accel, tangential accel
            struct {
                fzFloat     dirX;
                fzFloat     dirY;
                fzFloat		radialAccel;
                fzFloat		tangentialAccel;
            } A;
            
            // Mode B: radius mode
            struct {
                fzFloat		angle;
                fzFloat		degreesPerSecond;
                fzFloat		radius;
                fzFloat		deltaRadius;
            } B;
        } mode;
        
    } tFZParticle;
        
    
    /** Particle System base class
     Attributes of a Particle System:
     - emmision rate of the particles
     - Gravity Mode (Mode A):
     - gravity
     - direction
     - speed +-  variance
     - tangential acceleration +- variance
     - radial acceleration +- variance
     - Radius Mode (Mode B):
     - startRadius +- variance
     - endRadius +- variance
     - rotate +- variance
     - Properties common to all modes:
     - life +- life variance
     - start spin +- variance
     - end spin +- variance
     - start size +- variance
     - end size +- variance
     - start color +- variance
     - end color +- variance
     - life +- variance
     - blending function
     - texture
     
     FORZE also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).
     'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in FORZE,
     FORZE uses a another approach, but the results are almost identical. 
     
     FORZE supports all the variables used by Particle Designer plus a bit more:
     - spinning particles (supported when using CCParticleSystemQuad)
     - tangential acceleration (Gravity mode)
     - radial acceleration (Gravity mode)
     - radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only)
     
     It is possible to customize any of the above mentioned properties in runtime. Example:
     
     @code
     emitter.radialAccel = 15;
     emitter.startSpin = 0;
     @endcode
     
     */
    class ParticleSystem : public Node, public TextureProtocol
    {
    protected:
        // Start color of the particles
        fzColor4F startColor_;
        // Start color variance
        fzColor4F startColorVar_;
        // End color of the particles
        fzColor4F endColor_;
        // End color variance
        fzColor4F endColorVar_;
        
        // position is from "superclass" CocosNode
        fzPoint sourcePosition_;
        // Position variance
        fzPoint posVar_;
        
        // is the particle system active ?
        fzFloat isActive_;
        // duration in seconds of the system. -1 is infinity
        fzFloat duration_;
        // time elapsed since the start of the system (in seconds)
        fzFloat elapsed_;
        // The angle (direction) of the particles measured in degrees
        fzFloat angle_;
        // Angle variance measured in degrees;
        fzFloat angleVar_;
        
        // start ize of the particles
        fzFloat startSize_;
        // start Size variance
        fzFloat startSizeVar_;
        // End size of the particle
        fzFloat endSize_;
        // end size of variance
        fzFloat endSizeVar_;
        
        // How many seconds will the particle live
        fzFloat life_;
        // Life variance
        fzFloat lifeVar_;
        
        // start angle of the particles
        fzFloat startSpin_;
        // start angle variance
        fzFloat startSpinVar_;
        // End angle of the particle
        fzFloat endSpin_;
        // end angle ariance
        fzFloat endSpinVar_;
        
        // Different modes
        fzInt emitterMode_;
        
        union {
            // Mode A:Gravity + Tangential Accel + Radial Accel
            struct {
                fzFloat gravityX;
                fzFloat gravityY;
                fzFloat speed;
                fzFloat speedVar;
                fzFloat tangentialAccel;
                fzFloat tangentialAccelVar;
                fzFloat radialAccel;
                fzFloat radialAccelVar;
            } A;
            
            // Mode B: circular movement
            struct {
                fzFloat startRadius;
                fzFloat startRadiusVar;
                fzFloat endRadius;
                fzFloat endRadiusVar;			
                fzFloat rotatePerSecond;
                fzFloat rotatePerSecondVar;
            } B;
        } mode;
        
        

        // Maximum particles
        fzUInt totalParticles_;
        // Count of active particles
        fzUInt particleCount_;
        //  particle idx
        fzUInt particleIdx_;
        

        // How many particles can be emitted per second
        fzFloat emissionRate_;
        fzFloat emitCounter_;
        
        // Array of particles
        tFZParticle *particles_;
        // Texture of the particles
        Texture2D *texture_;
        // blend function
        fzBlendFunc	blendFunc_;
        
        // movment type: free or grouped
        tFZPositionType	positionType_;
        
        // Whether or not the node will be auto-removed when there are not particles
        bool	autoRemoveOnFinish_;
    
        
    public:
        /** initializes a CCParticleSystem from a plist file.
         This plist files can be creted manually or with Particle Designer:
         http://particledesigner.71squared.com/
         */
        //ParticleSystem(const STD::string& plistFile);
        
        //! initializes a CCQuadParticleSystem from a NSDictionary.
        //ParticleSystem(const std::map& dictionary);
        
        //! Initializes a system with a fixed number of particles
        ParticleSystem(fzUInt numberOfParticles, Texture2D *texture);
        
        // Destructor
        ~ParticleSystem();
        
        //! Add a particle to the emitter
        bool addParticle();
        
        //! Initializes a particle
        void initParticle(tFZParticle& particle);
        
        //! stop emitting particles. Running particles will continue to run until they die
        void stopSystem();
        
        //! Kill all living particles.
        void resetSystem();
        
        //! whether or not the system is full
        bool isFull() const;
        
        //! should be overriden by subclasses
        virtual void updateQuadWithParticle(const tFZParticle& particle, const fzPoint& pos) = 0;
        
#if FZ_VBO_STREAMING
        //! should be overriden by subclasses
        virtual void postStep() = 0;
#endif
        
        //! called in every loop.
        void update(fzFloat dt);
        
        //! Is the emitter active
        void setIsActive(bool);
        bool getIsActive() const;
        
        //! Quantity of particles that are being simulated at the moment
        bool getParticleCount() const;
        
        //! How many seconds the emitter wil run. -1 means 'forever'
        void setDuration(fzFloat);
        fzFloat getDuration() const;
        
        //! sourcePosition of the emitter
        void setSourcePosition(const fzPoint&);
        const fzPoint& getSourcePosition() const;
        
        //! Position variance of the emitter
        void setPosVar(const fzPoint&);
        const fzPoint& getPosVar() const;
        
        //! Gravity value. Only available in 'Gravity' mode
        void setGravity(const fzPoint&);
        const fzPoint& getGravity() const;
        
        //! life, and life variation of each particle
        void setLife(fzFloat);
        fzFloat getLife() const;
        
        //! life variance of each particle
        void setLifeVar(fzFloat);
        fzFloat getLifeVar() const;
        
        //! angle and angle variation of each particle
        void setAngle(fzFloat);
        fzFloat getAngle() const;
        
        //! angle variance of each particle
        void setAngleVar(fzFloat);
        fzFloat getAngleVar() const;
        
        //! speed of each particle. Only available in 'Gravity' mode
        void setSpeed(fzFloat);
        fzFloat getSpeed() const;
        
        //! speed variance of each particle. Only available in 'Gravity' mode
        void setSpeedVar(fzFloat);
        fzFloat getSpeedVar() const;
        
        //! tangential acceleration of each particle. Only available in 'Gravity' mode
        void setTangentialAccel(fzFloat);
        fzFloat getTangentialAccel() const;
        
        //! tangential acceleration variance of each particle. Only available in 'Gravity' mode
        void setTangentialAccelVar(fzFloat);
        fzFloat getTangentialAccelVar() const;
        
        //! radial acceleration of each particle. Only available in 'Gravity' mode
        void setRadialAccel(fzFloat);
        fzFloat getRadialAccel() const;
        
        //! radial acceleration variance of each particle. Only available in 'Gravity' mode
        void setRadialAccelVar(fzFloat);
        fzFloat getRadialAccelVar() const;
        
        //! The starting radius of the particles. Only available in 'Radius' mode
        void setStartRadius(fzFloat);
        fzFloat getStartRadius() const;
        
        //! The starting radius variance of the particles. Only available in 'Radius' mode
        void setStartRadiusVar(fzFloat);
        fzFloat getStartRadiusVar() const;
        
        //! The ending radius of the particles. Only available in 'Radius' mode
        void setEndRadius(fzFloat);
        fzFloat getEndRadius() const;
        
        //! The ending radius variance of the particles. Only available in 'Radius' mode
        void setEndRadiusVar(fzFloat);
        fzFloat getEndRadiusVar() const;
        
        //! Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode.
        void setRotatePerSecond(fzFloat);
        fzFloat getRotatePerSecond() const;
        
        //! Variance in degrees for rotatePerSecond. Only available in 'Radius' mode.
        void setRotatePerSecondVar(fzFloat r);
        fzFloat getRotatePerSecondVar() const;
        
        //! start size in pixels of each particle
        void setStartSize(fzFloat s);
        fzFloat getStartSize() const;
        
        //! size variance in pixels of each particle
        void setStartSizeVar(fzFloat s);
        fzFloat getStartSizeVar() const;
        
        //! end size in pixels of each particle
        void setEndSize(fzFloat s);
        fzFloat getEndSize() const;
        
        //! end size variance in pixels of each particle
        void setEndSizeVar(fzFloat);
        fzFloat getEndSizeVar() const;
        
        //! start color of each particle
        void setStartColor(const fzColor4F&);
        const fzColor4F& getStartColor() const;
        
        //! start color variance of each particle
        void setStartColorVar(const fzColor4F&);
        const fzColor4F& getStartColorVar() const;
        
        //! end color and end color variation of each particle
        void setEndColor(const fzColor4F&);
        const fzColor4F& getEndColor() const;
        
        //! end color variance of each particle
        void setEndColorVar(const fzColor4F&);
        const fzColor4F& getEndColorVar() const;
        
        //! initial angle of each particle
        void setStartSpin(fzFloat);
        fzFloat getStartSpin() const;
        
        //! initial angle of each particle
        void setStartSpinVar(fzFloat);
        fzFloat getStartSpinVar() const;
        
        //! initial angle of each particle
        void setEndSpin(fzFloat);
        fzFloat getEndSpin() const;
        
        //! initial angle of each particle
        void setEndSpinVar(fzFloat);
        fzFloat getEndSpinVar() const;
        
        //! emission rate of the particles
        void setEmissionRate(fzFloat);
        fzFloat getEmissionRate() const;
        
        //! maximum particles of the system
        void setTotalParticles(fzUInt);
        fzUInt getTotalParticles() const;
        
        //! conforms to CocosNodeTexture protocol
        virtual void setTexture(Texture2D*);
        Texture2D* getTexture() const;
        
        //! conforms to CocosNodeTexture protocol
        void setBlendFunc(const fzBlendFunc&);
        const fzBlendFunc& getBlendFunc() const;
        
        //! particles movement type: Free or Grouped
        void setPositionType(tFZPositionType);
        tFZPositionType getPositionType() const;
        
        //! whether or not the node will be auto-removed when it has no particles left
        void setAutoRemoveOnFinish(bool);
        bool getAutoRemoveOnFinish() const;
        
        /** Switch between different kind of emitter modes:
         - kCCParticleModeGravity: uses gravity, speed, radial and tangential acceleration
         - kCCParticleModeRadius: uses radius movement + rotation
         */
        void setEmitterMode(fzInt);
        fzInt getEmitterMode() const;
    };
}
#endif
